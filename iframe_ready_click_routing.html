<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title></title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Load Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

  <!-- Load Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Leaflet GeometryUtil extension for distance calculations -->
  <script src="https://unpkg.com/leaflet-geometryutil"></script>
  
  <link rel="stylesheet" href="https://res.cloudinary.com/da0bnopjg/raw/upload/v1752241565/L.Control.Boating_dauorv.css" />
<script src="https://res.cloudinary.com/da0bnopjg/raw/upload/v1752200366/L.Control.Boating_j9kccx.js"></script>
  
  <!-- Main CSS styling -->
  <style>
    html, body {
      height: auto;
      margin: 0;
      padding: 0;
      overflow: visible;
    }
    .main-container {
      max-width: 960px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
    }
    .ui-container {
      padding-bottom: 10px;
      padding-top: 10px;
      z-index: 1000;
    }
    .top-row {
      margin-bottom: 10px;
      position: relative;
    }
    .middle-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      gap: 10px;
    }
    .middle-row select,
    .middle-row button {
      padding: 8px;
      font-size: 14px;
    }
    .bottom-row {
      display: flex;
      justify-content: space-between;
      gap: 10px;
    }
    .info-box {
      flex: 1;
      background: #5896ed;
      color: white;
      padding: 10px;
      text-align: center;
      border-radius: 5px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
      font-family: Arial, sans-serif;
      height: 84px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    .info-label {
      font-weight: 300;
      font-size: 14px;
      opacity: 0.85;
    }
    .label {
      font-family: Arial, sans-serif;
    }
    .info-value {
      font-weight: 700;
      font-size: 18px;
      margin-top: 4px;
    }
    .map-container {
      height: 450px;
      position: relative;
    }
    #map {
      height: 100%;
      width: 100%;
    }
    .styled-bar {
      height: 42px;
      padding: 8px;
      font-size: 16px;
      width: 100%;
      box-sizing: border-box;
    }
	    /* Container style */
    .suggestion-box, .suggestion-box2 {
      position: absolute;
      top: 100%;		
	  background: white;	
      /*background-color: #f0f0f0; /* Light grey */
      z-index: 1001;
      border: 1px solid #ccc;
      cursor: pointer;
      color: black;
      font-family: Arial;
    }

    /* Individual suggestion item */
    .autocomplete-suggestion {
      padding: 1px 2px;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    /* Hover effect */
    .autocomplete-suggestion:hover {
      background-color: #5896ed; /* Blue */
      color: white;
    }
   /* .suggestion-box, .suggestion-box2 {
      position: absolute;
      top: 100%;
      background: #5896ed;
      z-index: 1001;
      border: 1px solid #ccc;
      cursor: pointer;
      color: white;
      font-family: Arial, sans-serif;
    }*/
    .suggestion-box {
      width: 50%;
    }
    .suggestion-box2 {
      width: 100%;
    }
    #route-button {
      background-color: #e63946;
      color: white;
      border: none;
      cursor: pointer;
    }
    #route-button:hover {
      background-color: #d62828;
    }
  </style>
</head>
<body style="margin: 0;">
  <h1 style="text-align: left; font-size: 32px; font-family: Arial, sans-serif; margin: 20px 0;">HOW LONG TO OPEN WATER</h1>
  <div class="main-container">
    <div class="ui-container">
	  <div class="top-row" style="display: flex; flex-direction: row; gap: 10px; align-items: flex-start;">
        <div style="flex: 1; display: flex; flex-direction: column; gap: 5px;">
          <label style="font-weight: bold;font-family: Arial, sans-serif;">From:</label>
          <input type="text" id="address-input" placeholder="Enter address..." class="styled-bar">
          <div id="suggestions" class="suggestion-box"></div>
        </div>
        <div style="flex: 1; display: flex; flex-direction: column; gap: 5px; position: relative;">
          <label style="font-weight: bold;font-family: Arial, sans-serif;">To:</label>
          <div id="poi-container" style="width: 100%;">
            <select id="destination-select" class="styled-bar">
              <option value="openWater">Open Water</option>
              <option value="cellini_citrus">Cellini Citrus</option>
              <option value="tarponMarina">Pinchers Cape Coral</option>
            </select>
            <input type="text" id="destination-address" placeholder="Enter destination..." class="styled-bar" style="display: none;" />
            <div id="destination-suggestions" class="suggestion-box2"></div>
          </div>
          <div style="display: flex; gap: 10px; justify-content: flex-end;">
            <label style="font-family: Arial, sans-serif;"><input type="radio" name="dest-type" value="poi" checked> POIs</label>
            <label style="font-family: Arial, sans-serif;"><input type="radio" name="dest-type" value="address"> Address</label>
          </div>
        </div>
      </div>
      <div class="middle-row">
        <div style="display: flex; align-items: center; gap: 8px;">
          <label for="speed-select" style="font-size:14px; font-weight:bold;font-family: Arial, sans-serif;">Max Speed:</label>
          <select id="speed-select">
            <option value="5">5 mph</option><option value="10">10 mph</option><option value="15">15 mph</option>
            <option value="20">20 mph</option><option value="25">25 mph</option><option value="30">30 mph</option>
            <option value="35">35 mph</option><option value="40">40 mph</option><option value="45">45 mph</option>
            <option value="50">50 mph</option><option value="55">55 mph</option><option value="60">60 mph</option>
          </select>
        </div>
        <button id="route-button">Get Directions</button>
      </div>
      <div class="bottom-row" id="scroll-target">
        <div class="info-box" id="distance-box">Distance: --</div>
        <div class="info-box" id="time-box">Time: --</div>
        <div class="info-box" id="clearance-box">Min Clearance: --</div>
      </div>
    </div>
    <div class="map-container">
      <div id="map"></div>
    </div>
  </div>
 <script>
// === Initialize the Leaflet map ===
/*// Centered on Cape Coral, FL with zoom level 13
let map = L.map('map').setView([26.6, -81.98], 13);

// === Add OpenStreetMap tile layer ===
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);
*/


// Create base layers
const streetMap = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; OpenStreetMap contributors'
});

const satelliteMap = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',  {
    attribution: 'Tiles &copy; Esri &mdash; Source: Esri, Maxar, Earthstar Geographics, and the GIS User Community'
});

const noaaEnc = L.tileLayer.wms(
  'https://gis.charttools.noaa.gov/arcgis/rest/services/MCS/ENCOnline/MapServer/exts/MaritimeChartService/WMSServer', {
    layers: '0,3,4,5,6', // '0' is the ENC display layer
    format: 'image/png',
    transparent: false,
    version: '1.3.0',
    attribution: 'Â© NOAA ENC Online'
});

const streetsOverlay = L.tileLayer(
  'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
    opacity: 0.4, // make streets semi-transparent
    attribution: '&copy; OpenStreetMap contributors'
});
const blended = L.layerGroup([noaaEnc, streetsOverlay]);


// Initialize the map
const map = L.map('map', {
  center: [26.6, -81.98],
  zoom: 13,
  layers: [streetMap]  // default layer
});

// Add layer switcher
const baseMaps = {
  "Street Map": streetMap,
  "Satellite": satelliteMap,
  "Nautical": noaaEnc,
  'Blended': blended


};

L.control.layers(baseMaps).addTo(map);
L.control.boating().addTo(map)



// === Define global variables ===
let fromMarker = null; // Marker for "From" location
let toMarker = null; // Marker for "To" location
let fromAddressLatLng = null; // Coordinates of selected "From" point
let toAddressLatLng = null; // Coordinates of selected "To" point
let graph = {}; // Graph data for Dijkstra routing
let segmentMap = {}; // Maps segment_id to segment data
let startNode = null; // Starting node ID in the graph
let endNode = null; // Ending node ID in the graph
let addressPoints = []; // List of address point features
let canalDataReady = false; // Flag to enable routing after canal data loads
let routeLine; // Polyline object(s) for displayed route
let bridgeMarkers = []; // Markers for bridge clearance info

// === URLs to GeoJSON resources (stored in Cloudinary) ===
const CANAL_GEOJSON_URL = 'https://res.cloudinary.com/da0bnopjg/raw/upload/v1751914031/forwardTest3_ls3ify.geojson';
const ADDRESS_GEOJSON_URL = 'https://res.cloudinary.com/da0bnopjg/raw/upload/v1751043675/Gulf_Access_Points_Master_vdfpde.geojson';
const NAVAID_GEOJSON_URL = 'https://res.cloudinary.com/da0bnopjg/raw/upload/v1752634446/Markers6_ytzjc0.geojson';
let navaidLayerGroup = L.layerGroup().addTo(map);
function getNavaidIconSize(zoom) {
  // Clamp zoom range from 14 â†’ 18
  const effectiveZoom = Math.max(14, Math.min(zoom, 18));
  const scale = (effectiveZoom - 14) * 8 + 8;  // Starts at 24px at zoom 14, goes to 54px at zoom 18
  return [scale, scale];
}

function addNavaidsToMap() {
  const zoom = map.getZoom(); // âœ… Get current zoom level at load

  fetch(NAVAID_GEOJSON_URL)
    .then(res => res.json())
    .then(data => {
      data.features.forEach(feature => {
        const [lng, lat] = feature.geometry.coordinates;
        const props = feature.properties;

        const type = props.navaid_type?.toLowerCase();
        const number = props.marker_num ?? null;
        const rawColor = props.COLOUR;
        const colorValues = rawColor
          ? rawColor.split(',').map(c => Number(c.trim()))
          : [];
        const popupText = props.OBJNAM || "Navaid";

        let iconSvg;

        if (type === "daybeacon") {
          if (colorValues.length === 1 && colorValues[0] === 3) {
            iconSvg = createRedDayBeaconSVG(number);
          } else if (colorValues.length === 1 && colorValues[0] === 4) {
            iconSvg = createGreenDayBeaconSVG(number);
          } else if (colorValues.length === 1 && colorValues[0] === 11) {
            iconSvg = createHazardDayBeaconSVG();
          } else if (colorValues.join(',') === '4,3,4') {
            iconSvg = createGreenRedGreenDayBeaconSVG();
          } else if (colorValues.join(',') === '3,4,3') {
            iconSvg = createRedGreenRedDayBeaconSVG(number);
          } else if (colorValues.join(',') === '1,1,3') {
            iconSvg = createSafeOctagonDayBeaconSVG();
          } else {
            console.warn(`âš ï¸ Skipping daybeacon with unsupported COLOUR: ${rawColor}`, props);
            return;
          }

        } else if (type === "buoy") {
          if (colorValues.length === 1 && colorValues[0] === 3) {
            iconSvg = createRedBuoySVG(number);
          } else if (colorValues.length === 1 && colorValues[0] === 4) {
            iconSvg = createGreenBuoySVG(number);
          } else if (colorValues.join(',') === '4,3,4') {
            iconSvg = createGreenRedGreenBuoySVG(number);
          } else {
            console.warn(`âš ï¸ Skipping buoy with unsupported COLOUR: ${rawColor}`, props);
            return;
          }

        } else if (type === "light") {
          if (colorValues.length === 1) {
            switch (colorValues[0]) {
              case 1:
                iconSvg = createWhiteLightSVG();
                break;
              case 3:
                iconSvg = createRedLightSVG();
                break;
              case 4:
                iconSvg = createGreenLightSVG();
                break;
              case 6:
                iconSvg = createYellowLightSVG();
                break;
              default:
                console.warn(`âš ï¸ Skipping light with unsupported COLOUR: ${rawColor}`, props);
                return;
            }
          } else {
            console.warn(`âš ï¸ Skipping light with invalid COLOUR value: ${rawColor}`, props);
            return;
          }

        } else if (type === "danger") {
          if (colorValues.length === 1) {
            switch (colorValues[0]) {
              case 95:
                iconSvg = createExposedWreckDangerSVG();
                break;
              case 96:
                iconSvg = createSubmergedWreckDangerSVG();
                break;
              case 97:
                iconSvg = createRocksDangerSVG();
                break;
              case 98:
                iconSvg = createCautionDangerSVG();
                break;
              case 99:
                iconSvg = createObstructionDangerSVG();
                break;
              default:
                console.warn(`âš ï¸ Skipping light with unsupported COLOUR: ${rawColor}`, props);
                return;
            }
          } else {
            console.warn(`âš ï¸ Skipping light with invalid COLOUR value: ${rawColor}`, props);
            return;
          }

        } else {
          iconSvg = createDefaultNavaidSVG();
        }

        // ðŸ”§ Adjust size and anchor based on type
        const isLight = type === "light";
        const baseSize = getNavaidIconSize(zoom);
        const iconSize = isLight
          ? [baseSize[0] * 2, baseSize[1] * 2]
          : baseSize;

        const iconAnchor = isLight
          ? [iconSize[0] / 2, iconSize[1] / 2] // Adjust as needed
          : [iconSize[0] / 2, iconSize[1]];

        const icon = L.icon({
          iconUrl: iconSvg,
          iconSize,
          iconAnchor
        });
        const zIndexOffset = isLight ? 0 : 1000; // lights stay low, others rise
        const marker = L.marker([lat, lng], { icon, zIndexOffset
        }).bindPopup(popupText);
        marker.feature = feature;
        navaidLayerGroup.addLayer(marker);
      });
    });
}


// === Utility function to convert mph to meters per second (used in travel time calc) ===
const mphToMps = (mph) => mph * 0.44704;

// === Utility function to calculate total distance (in miles) from a polyline ===
function calculateDistance(coords) {
    let d = 0;
    for (let i = 1; i < coords.length; i++) {
        d += map.distance(coords[i - 1], coords[i]);
    }
    return d * 0.000621371; // Convert meters to miles
}
// === colours for beacons lights and signs: 1-white,3-red,4-green,6-yellow,11-orange ===
// === colours for obstructions represent obstruction type: 99-obstruction,98-caution,97-awash,96-wreck === 
function createGreenDayBeaconSVG(number) {
  const label = number !== null ? `
    <text x="24" y="30" font-size="16" text-anchor="middle" fill="black" font-family="Arial">${number}</text>` : '';
  return `data:image/svg+xml;base64,${btoa(`<?xml version="1.0" encoding="UTF-8"?>
  <svg width="48" height="48" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg">
    <g>
      <rect style="fill:none;stroke:#4a6235;stroke-width:2.35" width="33.649" height="37.649" x="7.175" y="3.778"/>
      <rect style="fill:#55f786" width="31.297" height="35.297" x="8.352" y="4.953"/>
      ${label}
    </g>
  </svg>`)}`
}

function createRedDayBeaconSVG(number) {
  const label = number !== null ? `
    <text x="24" y="36" font-size="16" text-anchor="middle" fill="black" font-family="Arial">${number}</text>` : '';
  return `data:image/svg+xml;base64,${btoa(`<?xml version="1.0" encoding="UTF-8"?>
  <svg width="48" height="48" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg">
    <g>
      <path style="fill:#f75555" d="M 33.89,21.51 9.64,21.51 21.76,0.50 Z" transform="matrix(1.52,0,0,1.52,-9.27,7.80)" />
      <path style="fill:none;stroke:#8a0d0d;stroke-width:2.71" d="M 38.97,17.24 2.07,17.24 20.52,-14.72 Z" transform="matrix(1.14,0,0,1.14,0.40,22.30)" />
      ${label}
    </g>
  </svg>`)}`
}

function createGreenRedGreenDayBeaconSVG() {
  const svg = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg width="48" height="48" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg">
  <g>
    <rect
      style="display:inline;fill:#55f786;fill-opacity:1;stroke:none;stroke-width:0.218357"
      width="14"
      height="40"
      x="17"
      y="4" />
    <rect
      style="display:inline;fill:#f75555;fill-opacity:1;stroke:none;stroke-width:2.07605"
      width="14"
      height="9.0156116"
      x="17"
      y="13.788582" />
  </g>
</svg>`;
  return `data:image/svg+xml;base64,${btoa(svg)}`;
}

function createRedGreenRedDayBeaconSVG() {
  const svg = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg width="48" height="48" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg">
  <g>
    <rect
      style="display:inline;fill:#f75555;fill-opacity:1;stroke:none;stroke-width:0.218357"
      width="14"
      height="40"
      x="17"
      y="4" />
    <rect
      style="display:inline;fill:#55f786;fill-opacity:1;stroke:none;stroke-width:2.07605"
      width="14"
      height="9.0156116"
      x="17"
      y="13.788582" />
  </g>
</svg>`;
  return `data:image/svg+xml;base64,${btoa(svg)}`;
}

function createHazardDayBeaconSVG() {
  const svg = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   width="48"
   height="48"
   viewBox="0 0 48 48"
   version="1.1"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg">
  <g>
    <rect
       style="fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:0.214092;stroke-dasharray:none;stroke-opacity:1"
       width="13.4375"
       height="40.0625"
       x="17.546938"
       y="4.3306122" />
    <path
       style="fill:none;fill-opacity:1;stroke:#ffc523;stroke-width:3.53189;stroke-dasharray:none;stroke-opacity:1"
       d="M 19.5625,24.4375 8,12.875 19.5625,1.3125 31.125,12.875 Z"
       transform="matrix(0.41481749,0,0,0.77301644,16.213322,12.534275)" />
  </g>
</svg>`;
  return `data:image/svg+xml;base64,${btoa(svg)}`;
}

function createSafeOctagonDayBeaconSVG() {
  const svg = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   width="48"
   height="48"
   viewBox="0 0 48 48"
   version="1.1"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg">
  <g>
    <g style="display:inline">
      <path
         style="display:inline;fill:#f75555;fill-opacity:1;stroke:#ffffff;stroke-width:1.87154;stroke-dasharray:none;stroke-opacity:1"
         d="m 1.2657608,-4.8303532 9.5934782,1e-7 6.783614,6.7836139 0,9.5934782 -6.783614,6.783614 -9.5934784,0 -6.7836138,-6.783614 1e-7,-9.5934784 z"
         transform="matrix(1.5976848,0,0,1.5978564,14.310856,13.213437)" />
      <rect
         style="display:inline;fill:#f75555;fill-opacity:1;stroke:#ffffff;stroke-width:2.79144;stroke-dasharray:none;stroke-opacity:1"
         width="0.20855899"
         height="24.583561"
         x="11.39572"
         y="11.395719" />
      <rect
         style="display:inline;fill:#f75555;fill-opacity:1;stroke:#ffffff;stroke-width:2.85555;stroke-dasharray:none;stroke-opacity:1"
         width="0.14444545"
         height="37.144447"
         x="23.927774"
         y="5.4277749" />
      <rect
         style="display:inline;fill:#f75555;fill-opacity:1;stroke:#ffffff;stroke-width:2.85555;stroke-dasharray:none;stroke-opacity:1"
         width="0.14444545"
         height="37.144447"
         x="30.427776"
         y="5.4277773" />
      <rect
         style="display:inline;fill:#f75555;fill-opacity:1;stroke:#ffffff;stroke-width:2.79144;stroke-dasharray:none;stroke-opacity:1"
         width="0.20855899"
         height="24.583561"
         x="36.395721"
         y="11.39572" />
      <rect
         style="fill:#f75555;fill-opacity:1;stroke:#ffffff;stroke-width:2.85555;stroke-dasharray:none;stroke-opacity:1"
         width="0.14444545"
         height="37.144447"
         x="17.427776"
         y="5.4277773" />
    </g>
  </g>
</svg>`;
  return `data:image/svg+xml;base64,${btoa(svg)}`;
}

function createGreenBuoySVG(number) {
  const label = number !== null ? `
    <text x="30" y="32" font-size="16" text-anchor="middle" fill="black" font-family="Arial">${number}</text>` : '';
  
  return `data:image/svg+xml;base64,${btoa(`<?xml version="1.0" encoding="UTF-8"?>
  <svg width="48" height="48" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg">
    <g transform="translate(1,0)">
      <path style="fill:#55f786;stroke:#000000;stroke-width:0.2;" d="m 26.553073,3.7537177 -9.106146,-1e-7 L 22,-4.1324353 Z"
            transform="matrix(1.2079755,0,0,1.2377585,-3.5754609,5.3575217)" />
      <rect style="fill:#55f786;stroke:#000000;stroke-width:0.2;" width="11" height="38" x="17.5" y="10" />
      <rect style="fill:#55f786;stroke:#000000;stroke-width:0.2;" width="10.797" height="1.797" x="17.601" y="10.101" />
      <rect style="fill:#55f786;stroke:#000000;stroke-width:0.2;" width="10.797" height="1.797" x="17.601" y="34.101" />
      <rect style="fill:#55f786;stroke:#000000;stroke-width:0.22;" width="12.78" height="1.78" x="16.61" y="46.11" />
      ${label}
    </g>
  </svg>`)}`
}

function createRedBuoySVG(number) {
  const label = number !== null ? `
    <text x="30" y="32" font-size="16" text-anchor="middle" fill="black" font-family="Arial">${number}</text>` : '';
  
  return `data:image/svg+xml;base64,${btoa(`<?xml version="1.0" encoding="UTF-8"?>
  <svg width="48" height="48" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg">
    <g transform="translate(1,0)">
      <path style="fill:#f75555;stroke:#000000;stroke-width:0.2;" d="m 26.553073,3.7537177 -9.106146,-1e-7 L 22,-4.1324353 Z"
            transform="matrix(1.2079755,0,0,1.2377585,-3.5754609,5.3575217)" />
      <rect style="fill:#f75555;stroke:#000000;stroke-width:0.2;" width="11" height="38" x="17.5" y="10" />
      <rect style="fill:#f75555;stroke:#000000;stroke-width:0.2;" width="10.797" height="1.797" x="17.601" y="10.101" />
      <rect style="fill:#f75555;stroke:#000000;stroke-width:0.2;" width="10.797" height="1.797" x="17.601" y="34.101" />
      <rect style="fill:#f75555;stroke:#000000;stroke-width:0.22;" width="12.78" height="1.78" x="16.61" y="46.11" />
      ${label}
    </g>
  </svg>`)}`
}

function createGreenLightSVG() {
  return `data:image/svg+xml;base64,${btoa(`<?xml version="1.0" encoding="UTF-8"?>
<svg width="96" height="96" viewBox="0 0 96 96" xmlns="http://www.w3.org/2000/svg">
  <g transform="translate(44,48)">
    <g transform="translate(-3.6367188,-2.0625)">
      <path
        style="fill:#55f786;fill-opacity:1;stroke:none;stroke-width:3.1;stroke-dasharray:none;stroke-opacity:1"
        transform="rotate(-6.0378257)"
        d="M 35.433382,19.102105 A 10.474019,10.474019 0 0 1 37.659878,33.741155 10.474019,10.474019 0 0 1 23.022364,35.97773 10.474019,10.474019 0 0 1 20.77571,21.34176 10.474019,10.474019 0 0 1 35.410129,19.085029"/>
      <path
        style="fill:#55f786;fill-opacity:1;stroke:none;stroke-width:0.200059;stroke-dasharray:none;stroke-opacity:1"
        d="M 23.390625,30.336885 3.6367188,2.0625 35.847656,14.581962"/>
    </g>
  </g>
</svg>`)}`
}

function createRedLightSVG() {
  return `data:image/svg+xml;base64,${btoa(`<?xml version="1.0" encoding="UTF-8"?>
  <svg width="96" height="96" viewBox="0 0 96 96" xmlns="http://www.w3.org/2000/svg">
    <g transform="translate(44,48)">
      <g transform="translate(-3.6367188,-2.0625)">
        <path
          style="fill:#f75555;fill-opacity:1;stroke:none;stroke-width:3.1"
          transform="rotate(-6.0378257)"
          d="M 35.433382,19.102105 A 10.474019,10.474019 0 0 1 37.659878,33.741155 10.474019,10.474019 0 0 1 23.022364,35.97773 10.474019,10.474019 0 0 1 20.77571,21.34176 10.474019,10.474019 0 0 1 35.410129,19.085029" />
        <path
          style="fill:#f75555;fill-opacity:1;stroke:none;stroke-width:0.2"
          d="M 23.390625,30.336885 3.6367188,2.0625 35.847656,14.581962" />
      </g>
    </g>
  </svg>`)}`
}

function createYellowLightSVG() {
  return `data:image/svg+xml;base64,${btoa(`<?xml version="1.0" encoding="UTF-8"?>
<svg width="96" height="96" viewBox="0 0 96 96" xmlns="http://www.w3.org/2000/svg">
  <g transform="translate(44,48)">
    <g transform="translate(-3.6367188,-2.0625)">
      <path
        style="fill:#f6f52c;fill-opacity:1;stroke:none;stroke-width:3.1;stroke-dasharray:none;stroke-opacity:1"
        transform="rotate(-6.0378257)"
        d="M 35.433382,19.102105 A 10.474019,10.474019 0 0 1 37.659878,33.741155 10.474019,10.474019 0 0 1 23.022364,35.97773 10.474019,10.474019 0 0 1 20.77571,21.34176 10.474019,10.474019 0 0 1 35.410129,19.085029" />
      <path
        style="fill:#f6f52c;fill-opacity:1;stroke:none;stroke-width:0.200059;stroke-dasharray:none;stroke-opacity:1"
        d="M 23.390625,30.336885 3.6367188,2.0625 35.847656,14.581962" />
    </g>
  </g>
</svg>`)}`
}

function createWhiteLightSVG() {
  return `data:image/svg+xml;base64,${btoa(`<?xml version="1.0" encoding="UTF-8"?>
<svg width="96" height="96" viewBox="0 0 96 96" xmlns="http://www.w3.org/2000/svg">
  <g transform="translate(44,48)">
    <g transform="translate(-3.6367188,-2.0625)">
      <path
        style="fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:3.1;stroke-dasharray:none;stroke-opacity:1"
        transform="rotate(-6.0378257)"
        d="M 35.433382,19.102105 A 10.474019,10.474019 0 0 1 37.659878,33.741155 10.474019,10.474019 0 0 1 23.022364,35.97773 10.474019,10.474019 0 0 1 20.77571,21.34176 10.474019,10.474019 0 0 1 35.410129,19.085029" />
      <path
        style="fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:0.200059;stroke-dasharray:none;stroke-opacity:1"
        d="M 23.390625,30.336885 3.6367188,2.0625 35.847656,14.581962" />
    </g>
  </g>
</svg>`)}`
}

function createExposedWreckDangerSVG() {
  const svg = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   width="48"
   height="48"
   viewBox="0 0 48 48"
   version="1.1"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg">
  <g>
    <g transform="matrix(1.5889389,0,0,1.5999858,-13.631976,-8.8023736)">
      <path
         style="fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:1.5;stroke-dasharray:none;stroke-opacity:1"
         d="m 24.893677,22.792727 a 1.5026019,1.5026019 0 0 1 0.319413,2.100117 1.5026019,1.5026019 0 0 1 -2.099897,0.320859 1.5026019,1.5026019 0 0 1 -0.322304,-2.099675 1.5026019,1.5026019 0 0 1 2.099452,-0.323751" />
      <path
         style="fill:#ffffff;fill-opacity:1;stroke:#ffffff;stroke-width:2.054;stroke-linecap:round;stroke-dasharray:none;stroke-opacity:1"
         d="M 16.214479,23.423059 H 31.165985" />
      <path
         style="fill:#ffffff;fill-opacity:1;stroke:#ffffff;stroke-width:1.53717;stroke-linecap:round;stroke-linejoin:round;stroke-dasharray:none;stroke-opacity:1"
         d="m 22.204487,23.09754 -3.916395,-3.837183 10.269659,4.17085" />
      <path
         style="fill:#ffffff;fill-opacity:1;stroke:#ffffff;stroke-width:2.054;stroke-linecap:round;stroke-linejoin:round;stroke-dasharray:none;stroke-opacity:1"
         d="m 22.715805,21.92031 2.121321,-5.391689" />
    </g>
  </g>
</svg>`;
  return `data:image/svg+xml;base64,${btoa(svg)}`;
}

function createSubmergedWreckDangerSVG() {
  const svg = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   width="48"
   height="48"
   viewBox="0 0 48 48"
   version="1.1"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg">
  <g>
    <g>
      <path
         style="display:inline;fill:none;fill-opacity:1;stroke:#ffffff;stroke-width:1.19695;stroke-dasharray:1.19695, 3.59086;stroke-opacity:1"
         d="M 36.690619,12.403905 A 21.400053,14.401306 0 0 1 41.239696,32.531942 21.400053,14.401306 0 0 1 11.332975,35.607132 21.400053,14.401306 0 0 1 6.7427107,15.483331 21.400053,14.401306 0 0 1 36.64311,12.380426" />
      <path
         style="fill:none;stroke:#ffffff;stroke-width:1.4879"
         d="M 8,23.99395 H 40" />
      <path
         style="fill:none;stroke:#ffffff;stroke-width:1.51808"
         d="M 24.00904,14 V 34" />
      <path
         style="fill:none;stroke:#ffffff;stroke-width:1.5459"
         d="M 15.52295,18 V 30" />
      <path
         style="fill:none;stroke:#ffffff;stroke-width:1.5459"
         d="M 32.52295,18 V 30" />
    </g>
  </g>
</svg>`;
  return `data:image/svg+xml;base64,${btoa(svg)}`;
}

function createRocksDangerSVG() {
  const svg = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   width="48"
   height="48"
   viewBox="0 0 48 48"
   version="1.1"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg">
  <g>
    <path
       style="display:inline;fill:none;fill-opacity:1;stroke:#ffffff;stroke-width:1.5;stroke-dasharray:none;stroke-opacity:1"
       d="M 31.652631,39.63104 21.478369,22.212185 11.304105,39.631039 21.302145,22.110442 1.1298428,22.008698 21.302145,21.906957 11.304107,4.3863585 21.478369,21.805214 31.652633,4.3863595 21.654592,21.906957 41.826895,22.0087 21.654592,22.110442 Z"
       transform="matrix(0.98268788,0,0,1.0001847,2.8934345,1.9911724)" />
  </g>
</svg>`;
  return `data:image/svg+xml;base64,${btoa(svg)}`;
}

function createCautionDangerSVG() {
  const svg = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   width="48"
   height="48"
   viewBox="0 0 48 48"
   version="1.1"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg">
  <g>
    <path
       style="display:inline;fill:none;fill-opacity:1;stroke:#ffffff;stroke-width:1.5;stroke-dasharray:none;stroke-opacity:1"
       d="M 39.026296,40.440511 22.185474,23.837855 5.3446525,40.440511 21.947309,23.599689 5.3446524,6.7588676 22.185474,23.361524 39.026296,6.7588675 22.42364,23.599689 Z"
       transform="matrix(1.0359566,0,0,1.0365611,1.0164695,-0.45235884)" />
  </g>
</svg>`;
  return `data:image/svg+xml;base64,${btoa(svg)}`;
}

function createObstructionDangerSVG() {
  const svg = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   width="48"
   height="48"
   viewBox="0 0 48 48"
   version="1.1"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg">
  <g>
    <path
       style="display:inline;fill:none;fill-opacity:1;stroke:#ffffff;stroke-width:1.5;stroke-dasharray:1.5, 4.5;stroke-opacity:1"
       d="M 36.796032,5.9692985 A 22,22 0 0 1 41.472642,36.717677 22,22 0 0 1 10.727491,41.415458 22,22 0 0 1 6.0085394,10.67355 22,22 0 0 1 36.747191,5.9334305" />
  </g>
</svg>`;
  return `data:image/svg+xml;base64,${btoa(svg)}`;
}
// === Load and process the canal network data ===
let geojsonData; // Stores original GeoJSON object for reference

fetch(CANAL_GEOJSON_URL)
.then(res => res.json())
.then(data => {
    geojsonData = data; // Save full feature set for later lookups

    data.features.forEach(feature => {
        const { from_point, to_point, segment_id } = feature.properties;
        const coords = feature.geometry.coordinates.map(c => [c[1], c[0]]); // Convert [lng, lat] â†’ [lat, lng]
        const distance = calculateDistance(coords);

        // Build segmentMap (used in routing to get distance and coordinates)
        if (!segmentMap[segment_id]) {
            segmentMap[segment_id] = {
                feature,
                coords,
                distance
            };
        } else {
            console.warn("Duplicate during map load:", segment_id);
        }

        // Create bidirectional graph edges for Dijkstra
        if (!graph[from_point])
            graph[from_point] = [];
        if (!graph[to_point])
            graph[to_point] = [];

        graph[from_point].push({
            to: to_point,
            segment_id
        });
        // Note: Reverse direction intentionally left out here (may be added later)
    });

    canalDataReady = true;
    document.getElementById('route-button').disabled = false;
    console.log(`Graph initialized with ${data.features.length} segments.`);
});

// === Load and process the address points for autocomplete ===
fetch(ADDRESS_GEOJSON_URL)
.then(res => res.json())
.then(data => {
    data.features.forEach(feature => {
        feature.label = feature.properties.SITEADDR; // Store readable label
        addressPoints.push(feature); // Add to global address list
    });

    console.log(`Loaded ${addressPoints.length} address points.`);
    console.log("Sample addresses:", addressPoints.slice(0, 5));
});

// === Set up autocomplete behavior for input fields ===
// inputId: ID of the HTML input element
// suggestionsId: ID of the div used to show matching suggestions
// isDestination: true if this is the 'To' input, false for 'From'
function setupAutocomplete(inputId, suggestionsId, isDestination = false) {
    const input = document.getElementById(inputId);
    const suggestionBox = document.getElementById(suggestionsId);

    input.addEventListener('input', () => {
        const value = input.value.toLowerCase(); // convert typed text to lowercase
        suggestionBox.innerHTML = ''; // clear previous suggestions
        if (value.length < 2)
            return; // don't search unless 2+ characters

        // Filter address list for matches
        const matches = addressPoints.filter(f => f.properties?.SITEADDR?.toLowerCase().includes(value));

        // Show top 10 matches in the suggestion box
        matches.slice(0, 4).forEach(m => {
            const div = document.createElement('div');
			div.className = 'autocomplete-suggestion';  // âœ… Add this line
            div.innerText = m.properties.SITEADDR;

            // What happens when the user clicks a suggestion
            div.addEventListener('click', () => {
                const coords = m.geometry.coordinates; // [lng, lat]
                const latlng = [coords[1], coords[0]]; // Convert to [lat, lng]

                if (isDestination) {
                    endNode = findNearestNode(latlng[0], latlng[1], "to"); // store graph node for destination
                    if (toMarker)
                        map.removeLayer(toMarker);
                    toAddressLatLng = latlng;
                    toMarker = L.marker(toAddressLatLng, {
                        icon: createScaledIcon(toIconUrl, map.getZoom())
                    }).addTo(map);
                    console.log('Placed TO marker at', latlng);
                } else {
                    startNode = findNearestNode(latlng[0], latlng[1], "from"); // store graph node for start
                    if (fromMarker)
                        map.removeLayer(fromMarker);
                    fromAddressLatLng = latlng;
                    fromMarker = L.marker(fromAddressLatLng, {
                        icon: createScaledIcon(fromIconUrl, map.getZoom())
                    }).addTo(map);
                    console.log('Placed FROM marker at', latlng);
                }

                input.value = m.properties.SITEADDR; // update input box with chosen address
                suggestionBox.innerHTML = ''; // clear suggestions
            });

            suggestionBox.appendChild(div); // Add suggestion to list
        });
    });
}

// Attach autocomplete logic to input boxes
setupAutocomplete('address-input', 'suggestions');
setupAutocomplete('destination-address', 'destination-suggestions', true);

// === Switch input between POI dropdown and address entry ===
document.querySelectorAll('input[name="dest-type"]').forEach(radio => {
    radio.addEventListener('change', () => {
        const isPOI = document.querySelector('input[name="dest-type"]:checked').value === 'poi';
        document.getElementById('destination-select').style.display = isPOI ? 'block' : 'none';
        document.getElementById('destination-address').style.display = isPOI ? 'none' : 'block';
    });
});

// === Calculate geographic distance between two lat/lng points in km ===
function getDistanceFromLatLonInKm(lat1, lon1, lat2, lon2) {
    const R = 6371; // Earth's radius in kilometers
    const dLat = deg2rad(lat2 - lat1);
    const dLon = deg2rad(lon2 - lon1);
    const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
}

// === Convert degrees to radians ===
function deg2rad(deg) {
    return deg * (Math.PI / 180);
}

// === Find the nearest canal node within ~150 ft of a click or address ===
// Uses GeometryUtil to compute the perpendicular distance to canal segments
function findNearestNode(lat, lng, mode) {
    const clickLatLng = L.latLng(lat, lng);
    let closestFeature = null;
    let minDistFeet = 150;

    geojsonData.features.forEach(feature => {
        const coords = feature.geometry.coordinates;
        for (let i = 0; i < coords.length - 1; i++) {
            const p1 = L.latLng(coords[i][1], coords[i][0]);
            const p2 = L.latLng(coords[i + 1][1], coords[i + 1][0]);

            // Get shortest distance from point to canal segment line
            const dist = L.GeometryUtil.distanceSegment(map, clickLatLng, p1, p2);
            const distFeet = dist * 3.28084;

            // If this segment is closer, store it
            if (distFeet < minDistFeet) {
                minDistFeet = distFeet;
                closestFeature = feature;
            }
        }
    });

    if (!closestFeature)
        return null;

    // Use the from_point node for both from/to logic here
    return closestFeature.properties.from_point;
}

// === Allow user to click on the map to select FROM and TO nodes ===
// First click sets startNode, second click sets endNode and auto-triggers routing
map.on('click', (e) => {
    const latlng = e.latlng; // coordinates of click

    if (!startNode) {
        const node = findNearestNode(latlng.lat, latlng.lng, 'from');
        if (node) {
            startNode = node;
        }
    } else {
        const node = findNearestNode(latlng.lat, latlng.lng, 'to');
        if (node) {
            endNode = node;
            document.getElementById('route-button').click(); // auto-trigger routing
        }
    }
});

// === Dijkstra's Algorithm ===
// Calculates shortest travel time from start to end using graph data
function dijkstra(start, end, userSpeed) {
    const visited = new Set(); // tracks visited nodes
    const distances = {}; // total travel time to each node
    const prev = {}; // tracks path from start â†’ end

    // Set all distances to infinity initially
    Object.keys(graph).forEach(n => {
        distances[n] = Infinity;
    });
    distances[start] = 0;

    const pq = new Map(); // simple priority queue
    pq.set(start, 0);

    while (pq.size) {
        // Get node with smallest distance in queue
        const curr = [...pq.entries()].sort((a, b) => a[1] - b[1])[0][0];
        pq.delete(curr);

        if (curr === end)
            break;
        if (visited.has(curr))
            continue;
        visited.add(curr);

        for (const edge of graph[curr]) {
            const { to, segment_id } = edge;
            if (visited.has(to))
                continue;

            const segment = segmentMap[segment_id];
            if (!segment) {
                console.warn("Missing segment in segmentMap:", segment_id);
                continue;
            }

            const { coords, feature } = segment;
            if (!coords || coords.length < 2) {
                console.warn("Bad or missing coords for:", segment_id);
                continue;
            }

            const segSpeed = feature.properties.speed_mph; // allowed speed on this segment
            const distance = calculateDistance(coords);

            const effSpeed = Math.min(userSpeed, segSpeed || userSpeed); // respect segment limits
            const time = distance / effSpeed; // time = distance Ã· speed

            // If this route to "to" node is faster, update it
            if (distances[curr] + time < distances[to]) {
                distances[to] = distances[curr] + time;
                prev[to] = {
                    from: curr,
                    segment_id
                };
                pq.set(to, distances[to]);
            }
        }
    }

    // === Reconstruct shortest path ===
    const path = [],
    segIds = [];
    let node = end;
    let totalDistance = 0;

    while (prev[node]) {
        const { from, segment_id } = prev[node];
        path.unshift(from);
        segIds.unshift(segment_id);
        totalDistance += segmentMap[segment_id].distance;
        node = from;
    }
    path.push(end);

    // === Determine minimum bridge clearance on this route ===
    const minClearValues = segIds
        .map(id => segmentMap[id].feature.properties.min_cleara)
        .filter(val => val !== undefined && val !== null);

    const finalMinClear = minClearValues.length > 0
         ? Math.min(...minClearValues)
         : "No Bridges";

    return {
        path, // ordered list of node IDs in the route
        segIds, // segment IDs traversed
        totalTime: distances[end],
        totalDistance,
        minClear: finalMinClear
    };
}

// === Define color based on speed for polyline display ===
function getSpeedColor(speed) {
    if (speed >= 25)
        return 'green';
    return 'red';
}

// === Main route button logic ===
document.getElementById('route-button').addEventListener('click', () => {
    // Prevent routing if canal data hasn't loaded yet
    if (!canalDataReady) {
        alert("Canal data is still loading. Please wait a moment and try again.");
        return;
    }

    bridgeMarkers.forEach(marker => map.removeLayer(marker));
    bridgeMarkers = [];

    // Clear previous route markers
    if (fromMarker) {
        map.removeLayer(fromMarker);
        fromMarker = null;
    }
    if (toMarker) {
        map.removeLayer(toMarker);
        toMarker = null;
    }

    const speed = parseInt(document.getElementById('speed-select').value); // User-selected speed
    const destType = document.querySelector('input[name="dest-type"]:checked').value; // POI or Address

    if (destType === 'poi') {
        const poi = document.getElementById('destination-select').value;

        if (poi === 'openWater') {
            // Handle open water destination: pick fastest matching endpoint
            const candidates = Object.keys(graph).filter(p => p.toLowerCase().includes("openwater"));

            if (!candidates.length) {
                alert("No Open Water destinations found.");
                return;
            }

            let bestNode = null;
            let bestTime = Infinity;

            for (const candidate of candidates) {
                const result = dijkstra(startNode, candidate, speed);
                if (result.path.length && result.totalTime < bestTime) {
                    bestTime = result.totalTime;
                    bestNode = candidate;
                }
            }

            if (!bestNode) {
                alert("No reachable Open Water destination found.");
                return;
            }

            endNode = bestNode;

            // Try placing a marker visually on the last coordinate of the matching segment
            const endSegment = geojsonData.features.find(f => f.properties.to_point === endNode);
            if (endSegment) {
                const coords = endSegment.geometry.coordinates;
                const latlng = [coords[coords.length - 1][1], coords[coords.length - 1][0]];
                toAddressLatLng = latlng;
                toMarker = L.marker(toAddressLatLng, {
                    icon: createScaledIcon(toIconUrl, map.getZoom())
                }).addTo(map);
                console.log("Placed TO marker for Open Water at", latlng);
            }
        } else {
            // Handle static POI destinations
            const poiNodeMap = {
                cellini_citrus: 'cellini_citrus',
                tarponMarina: 'tarponMarina'
            };
            endNode = poiNodeMap[poi];

            const endSegment = geojsonData.features.find(f => f.properties.to_point === endNode);
            if (endSegment) {
                const coords = endSegment.geometry.coordinates;
                const latlng = [coords[coords.length - 1][1], coords[coords.length - 1][0]];
                if (toMarker)
                    map.removeLayer(toMarker);
                toAddressLatLng = latlng;
                toMarker = L.marker(toAddressLatLng, {
                    icon: createScaledIcon(toIconUrl, map.getZoom())
                }).addTo(map);
                console.log('Placed TO marker at', latlng);
            }
        }
    }

    // Log start/end and edge availability
    console.log("Start node:", startNode);
    console.log("Edges from start node:", graph[startNode]);
    console.log("End node:", endNode);
    console.log("Edges from end node:", graph[endNode]);

    // Re-render markers if they weren't replaced already
    if (!fromMarker && fromAddressLatLng) {
        fromMarker = L.marker(fromAddressLatLng, {
            icon: createScaledIcon(fromIconUrl, map.getZoom())
        }).addTo(map);
    }
    if (!toMarker && toAddressLatLng && destType === "address") {
        toMarker = L.marker(toAddressLatLng, {
            icon: createScaledIcon(toIconUrl, map.getZoom())
        }).addTo(map);
    }

    // Fallback in case marker not available but we have node
    if (!fromMarker && startNode) {
        const startSegment = geojsonData.features.find(f => f.properties.from_point === startNode);
        if (startSegment) {
            const coords = startSegment.geometry.coordinates;
            const latlng = [coords[0][1], coords[0][0]];
            fromAddressLatLng = latlng;
            fromMarker = L.marker(fromAddressLatLng, {
                icon: createScaledIcon(fromIconUrl, map.getZoom())
            }).addTo(map);
        }
    }
    if (!toMarker && endNode && destType === "address") {
        const endSegment = geojsonData.features.find(f => f.properties.to_point === endNode);
        if (endSegment) {
            const coords = endSegment.geometry.coordinates;
            const latlng = [coords[coords.length - 1][1], coords[coords.length - 1][0]];
            toAddressLatLng = latlng;
            toMarker = L.marker(toAddressLatLng, {
                icon: createScaledIcon(toIconUrl, map.getZoom())
            }).addTo(map);
        }
    }

    // Prevent route calculation if either point is missing
    if (!startNode || !endNode) {
        alert('Please select both a start and end location.');
        return;
    }

    const result = dijkstra(startNode, endNode, speed);
    if (!result.path.length) {
        alert('No route found.');
        return;
    }
    if (destType === 'address') {
        // === Replace old start segment with artificial_start ===
        const oldStartId = result.segIds[0];
        const oldStart = segmentMap[oldStartId];
        const oldStartCoords = oldStart.coords;

        const startInterp = L.GeometryUtil.closest(map, oldStartCoords, L.latLng(fromAddressLatLng));

        // Find where to splice in the interpolated point
        let insertIndexStart = oldStartCoords.findIndex((pt, i) => {
            if (i === oldStartCoords.length - 1)
                return false;
            const seg = [oldStartCoords[i], oldStartCoords[i + 1]];
            const dist = L.GeometryUtil.distanceSegment(map, L.latLng(startInterp), ...seg);
            return dist < .9; // tolerance threshold
        });

        if (insertIndexStart === -1)
            insertIndexStart = 0;
        const trimmedStartCoords = [startInterp, ...oldStartCoords.slice(insertIndexStart + 1)];

        segmentMap['artificial_start'] = {
            coords: trimmedStartCoords,
            feature: {
                properties: {
                    ...oldStart.feature.properties
                }
            }
        };

        result.segIds[0] = 'artificial_start';

        // === Replace old end segment with artificial_end ===
        const oldEndId = result.segIds[result.segIds.length - 1];
        const oldEnd = segmentMap[oldEndId];
        const oldEndCoords = oldEnd.coords;

        // Convert to LatLngs for GeometryUtil
        const latLngs = oldEndCoords.map(c => L.latLng(c));
        const endInterp = L.GeometryUtil.closest(map, latLngs, L.latLng(toAddressLatLng));

        let trimmedEndCoords = [];
        let found = false;

        for (let i = 0; i < latLngs.length - 1; i++) {
            const p1 = latLngs[i];
            const p2 = latLngs[i + 1];
            trimmedEndCoords.push([p1.lat, p1.lng]);

            const dist = L.GeometryUtil.distanceSegment(map, endInterp, p1, p2);
            console.log(`ðŸ” Segment ${i}: Distance from endInterp to [${p1.lat.toFixed(6)}, ${p2.lat.toFixed(6)}] = ${dist}`);

            if (dist < 0.9 && !found) {
                console.log(`âœ… Match found at segment ${i}, distance = ${dist}`);
                trimmedEndCoords.push([endInterp.lat, endInterp.lng]);
                found = true;
                break;
            }
        }

        if (!found) {
            // fallback: use full original coords
            trimmedEndCoords = oldEndCoords;
            console.warn("End interpolation segment not found â€” using original segment.");
        }

        segmentMap['artificial_end'] = {
            coords: trimmedEndCoords,
            feature: {
                properties: {
                    ...oldEnd.feature.properties
                }
            }
        };

        console.log("Final number of segments in route:", result.segIds.length);
        console.log("Final segment IDs:", result.segIds);

        result.segIds[result.segIds.length - 1] = 'artificial_end';
    }
    if (destType === 'poi') {
        // === Replace old start segment with artificial_start ===
        const oldStartId = result.segIds[0];
        const oldStart = segmentMap[oldStartId];
        const oldStartCoords = oldStart.coords;

        const startInterp = L.GeometryUtil.closest(map, oldStartCoords, L.latLng(fromAddressLatLng));

        // Find where to splice in the interpolated point
        let insertIndexStart = oldStartCoords.findIndex((pt, i) => {
            if (i === oldStartCoords.length - 1)
                return false;
            const seg = [oldStartCoords[i], oldStartCoords[i + 1]];
            const dist = L.GeometryUtil.distanceSegment(map, L.latLng(startInterp), ...seg);
            return dist < .9; // tolerance threshold
        });

        if (insertIndexStart === -1)
            insertIndexStart = 0;
        const trimmedStartCoords = [startInterp, ...oldStartCoords.slice(insertIndexStart + 1)];

        segmentMap['artificial_start'] = {
            coords: trimmedStartCoords,
            feature: {
                properties: {
                    ...oldStart.feature.properties
                }
            }
        };

        result.segIds[0] = 'artificial_start';

    }

    // Remove previous route polylines if any
    if (Array.isArray(routeLine)) {
        routeLine.forEach(line => map.removeLayer(line));
    } else if (routeLine) {
        map.removeLayer(routeLine);
    }
    routeLine = [];

    let allCoords = [];

    for (let i = 0; i < result.segIds.length; i++) {
        const segmentId = result.segIds[i];
        const segment = segmentMap[segmentId];
        if (i === result.segIds.length - 1) {
            console.log("Last segment ID:", segmentId);
            console.log("Last segment coordinates:", segment.coords);
        }

        if (!segment)
            continue;

        let coords = segment.coords;

        const from = segment.feature.properties.from_point;
        const to = segment.feature.properties.to_point;
        const expectedStart = result.path[i];
        const expectedEnd = result.path[i + 1];

        // Reverse if traveling backward on segment
        if (from === expectedEnd && to === expectedStart) {
            coords = [...coords].reverse();
        }

        const speed = segment.feature.properties.speed_mph || 0;
        const color = getSpeedColor(speed);

        const poly = L.polyline(coords, {
            color,
            weight: 4,
            opacity: 0.9
        }).addTo(map);

        routeLine.push(poly);

        // === Add bridge icon if this segment includes a clearance value ===
        const minClear = segment.feature.properties.min_cleara;
        if (minClear !== null && minClear !== undefined) {
            const midIndex = Math.floor(coords.length / 2); // Pick midpoint of segment
            const bridgeLatLng = coords[midIndex];

            // Convert clearance to feet and inches
            const feet = Math.floor(minClear);
            const inches = Math.round((minClear - feet) * 12);

            // Create and place bridge icon
            const marker = L.marker(bridgeLatLng, {
                icon: L.icon({
                    iconUrl: 'https://res.cloudinary.com/da0bnopjg/image/upload/v1751921623/bridge_2341064_slhkds.png',
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                })
            }).addTo(map)
                .bindTooltip(`Bridge Clearance: ${feet}ft ${inches}in.`, {
                    permanent: false,
                    direction: "top",
                    offset: [0, -10]
                });

            bridgeMarkers.push(marker); // Track marker so it can be removed on next route
        }
        allCoords.push(...coords);
    }

    // Zoom map to fit route
    if (allCoords.length >= 2) {
        map.fitBounds(L.latLngBounds(allCoords));
    } else {
        alert("Unable to draw route. Try selecting a different start or end location.");
    }

    // Format and display route info
    const totalDistanceText = `${result.totalDistance.toFixed(1)} mi`;
    const totalTimeHours = result.totalTime;
    const hours = Math.floor(totalTimeHours);
    const minutes = Math.round((totalTimeHours - hours) * 60);
    const timeDisplay = hours > 0 ? `${hours}h ${minutes}m` : `${minutes} min`;

    let minClearText;
    if (typeof result.minClear === "string") {
        minClearText = result.minClear;
    } else {
        const clearance = result.minClear || 0;
        const feet = Math.floor(clearance);
        const inches = Math.round((clearance - feet) * 12);
        minClearText = `${feet} ft ${inches} in`;
    }

    document.getElementById('distance-box').innerHTML = `Distance: ${totalDistanceText}`;
    document.getElementById('time-box').innerHTML = `Time: ${timeDisplay}`;
    document.getElementById('clearance-box').innerHTML = `Min Clearance: ${minClearText}`;

    // Scroll to results
    document.getElementById('scroll-target').scrollIntoView({
        behavior: 'smooth'
    });
});

// === Icon image URLs for start and end markers ===
const fromIconUrl = 'https://res.cloudinary.com/da0bnopjg/image/upload/v1751993412/start_placeholder_hihvwp.png';
const toIconUrl = 'https://res.cloudinary.com/da0bnopjg/image/upload/v1751993427/end_placeholder_b5qzy9.png';

// === Creates a marker icon scaled to current zoom level ===
function createScaledIcon(url, zoom, anchor = [0.5, 1]) {
    const size = Math.max(18, Math.min(zoom * 3, 48)); // size adjusts based on zoom level
    return L.icon({
        iconUrl: url,
        iconSize: [size, size],
        iconAnchor: [size * anchor[0], size * anchor[1]]
    });
}
/*
// === Redraws the markers with new icon sizes whenever zoom changes ===
map.on('zoomend', () => {
    const zoom = map.getZoom();
    if (fromMarker && fromAddressLatLng) {
        map.removeLayer(fromMarker);
        fromMarker = L.marker(fromAddressLatLng, {
            icon: createScaledIcon(fromIconUrl, zoom, [0.5, 1])
        }).addTo(map);
    }
    if (toMarker && toAddressLatLng) {
        map.removeLayer(toMarker);
        toMarker = L.marker(toAddressLatLng, {
            icon: createScaledIcon(toIconUrl, zoom, [0.5, 0.9])
        }).addTo(map);
    }
*/

// ðŸ§  Function to handle all zoom-based marker updates
function updateMarkersOnZoom() {
  const zoom = map.getZoom();
  console.log("Current zoom level:", zoom);

  // FROM marker icon resize
  if (fromMarker && fromAddressLatLng) {
    fromMarker.setIcon(createScaledIcon(fromIconUrl, zoom, [0.5, 1]));
  }

  // TO marker icon resize
  if (toMarker && toAddressLatLng) {
    toMarker.setIcon(createScaledIcon(toIconUrl, zoom, [0.5, 0.9]));
  }

  // Update each marker in navaidLayerGroup
  navaidLayerGroup.eachLayer(marker => {
    const props = marker.feature.properties;
    const type = props.navaid_type?.toLowerCase();
    const rawColor = props.COLOUR;
    const marker_num = props.marker_num ?? null;

    // Hide markers below zoom level 11
    if (zoom < 11) {
      marker.setOpacity(0);
      return;
    }

    marker.setOpacity(1);

    const colorValues = rawColor
      ? rawColor.split(',').map(c => Number(c.trim()))
      : [];

    let svg;

    // â›µ DAYBEACONS
    if (type === "daybeacon") {
      if (colorValues.length === 1 && colorValues[0] === 3) {
        svg = createRedDayBeaconSVG(marker_num);
      } else if (colorValues.length === 1 && colorValues[0] === 4) {
        svg = createGreenDayBeaconSVG(marker_num);
      } else if (colorValues.length === 1 && colorValues[0] === 11) {
        svg = createHazardDayBeaconSVG();
      } else if (colorValues.join(',') === '4,3,4') {
        svg = createGreenRedGreenDayBeaconSVG();
      } else if (colorValues.join(',') === '3,4,3') {
        svg = createRedGreenRedDayBeaconSVG();
      } else if (colorValues.join(',') === '1,1,3') {
        svg = createSafeOctagonDayBeaconSVG();
      } else {
        marker.setOpacity(0);
        return;
      }

    // ðŸ›Ÿ BUOYS
    } else if (type === "buoy") {
      if (colorValues.length === 1 && colorValues[0] === 3) {
        svg = createRedBuoySVG(marker_num);
      } else if (colorValues.length === 1 && colorValues[0] === 4) {
        svg = createGreenBuoySVG(marker_num);
      } else if (colorValues.join(',') === '4,3,4') {
        svg = createGreenRedGreenBuoySVG(marker_num);
      } else {
        marker.setOpacity(0);
        return;
      }

    // ðŸ’¡ LIGHTS
    } else if (type === "light") {
      if (colorValues.length === 1) {
        switch (colorValues[0]) {
          case 1: svg = createWhiteLightSVG(); break;
          case 3: svg = createRedLightSVG(); break;
          case 4: svg = createGreenLightSVG(); break;
          case 6: svg = createYellowLightSVG(); break;
          default: marker.setOpacity(0); return;
        }
      } else {
        marker.setOpacity(0);
        return;
      }

    // âš ï¸ DANGERS
    } else if (type === "danger") {
      if (colorValues.length === 1) {
        switch (colorValues[0]) {
          case 95: svg = createExposedWreckDangerSVG(); break;
          case 96: svg = createSubmergedWreckDangerSVG(); break;
          case 97: svg = createRocksDangerSVG(); break;
          case 98: svg = createCautionDangerSVG(); break;
          case 99: svg = createObstructionDangerSVG(); break;
          default: marker.setOpacity(0); return;
        }
      } else {
        marker.setOpacity(0);
        return;
      }

    // ðŸ§­ DEFAULT
    } else {
      svg = createDefaultNavaidSVG();
    }

    const isLight = type === "light";
    const baseSize = getNavaidIconSize(zoom);

    const iconSize = isLight
      ? [baseSize[0] * 2, baseSize[1] * 2]
      : baseSize;

    const iconAnchor = isLight
      ? [iconSize[0] / 2, iconSize[1] / 2]
      : [iconSize[0] / 2, iconSize[1]];

    const icon = L.icon({
      iconUrl: svg,
      iconSize,
      iconAnchor
    });

    marker.setIcon(icon);
  });
}

// ðŸ—ºï¸ Initialize Navaids First
addNavaidsToMap();

// â³ Debounced zoom event handler
let zoomTimeout;
map.on('zoomend', () => {
  clearTimeout(zoomTimeout);
  zoomTimeout = setTimeout(() => {
    updateMarkersOnZoom();
  }, 250); // Try 250ms â€” smooth but snappy
});

</script>
</body>
</html>
